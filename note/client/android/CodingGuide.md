
六大原则
## 单一职责
一个类只表达一个概念、一个方法只做一件事情。将一组相关性很高的函数、数据封装到一个类中。换句话说，一个类应该有职责单一。

## 开闭原则
一个类对于扩展是开放的，但是对于修改是封闭的。这也是六大原则中最难的，通常开闭都是短暂的美好，但在业务升级与拓展的状态下，原理的开闭是无法满足。即使是这样，也要尽可能的扩展而不是修改。

## 里氏替换原则
所有引用基类的地方必须能透明地使用其子类对象
举例: 

## 依赖倒置原则 解耦
高层模块不应该依赖底层模块，二者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象

## 接口隔离原则
类之间的依赖关系应该建立在最小的接口上

## 迪米特原则
一个对象应该对其他的对象有最少的了解 

23种设计模式

## 单例模式
确保单例类只有一个实例，并且这个单例类提供一个函数接口让其他类获取到这个唯一的实例
## 建造者模式
将一个复杂对象的构造与它的表示分离，使得同样的构造过程可以创建不同的表示
## 原型模式
使用一个实例拷贝后的实例
防止自己的实例在传入别的模块后，发生意外的修改

## 工厂方法
定义一个创建对象的接口，让子类决定实例化哪个类

## 抽象工厂
为创建一组相关或者是相互依赖的对象提供一个接口，而不需要制定他们的具体类
## 简单工厂
常被用于封装创建对象的代码 比如 getSystemService

## 策略模式
有一系列的算法，将每个算法封装起来（每个算法可以封装到不同的类中），各个算法之间可以替换，策略模式让算法独立于使用它的客户而独立变化
例如: Android的属性动画中使用时间插值器，就是策略模式

## 状态模式
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。
## 责任链模式
使多个对象都有机会处理请求，从而避免请求的发送者和接收者直接的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止
例如: 最好的一个例子就是View的测量，定位，绘制，事件传递，事件分发等。这些例子都是从父View开始依次向子View进行，是一个特别典型的责任链模式。特别要提到的是，savedInstance的处理也是责任链模式
## 解释器模式 
给定一个语言，定义它的语法，并定义个解释器，这个解释器用于解析语言。
AndroidManifest.xml是典型的一个自定义xml文件语言，layout目录下的xml文件，都是具有特殊语法的文件。他们都会被XmlPullParser这个解析器进行解释。
lrc markdown
## 命令模式
命令模式将每个请求封装成一个对象，从而让用户使用不同的请求把客户端参数化；将请求进行排队或者记录请求日志，以及支持可撤销操作
在Android底层的事件机制中，底层逻辑对事件的转发处理。每次的按键事件会被封装成NotifyKeyArgs对象，通过InputDispatcher封装具体的事件操作。
## 观察者模式
定义了对象之间的一对多的关系，其实就是1：n，当“1”发生变化时，“n”全部得到通知，并更新
观察者模式比较典型的场景就是发布消息通知订阅者。没错Android下的广播就是观察者模式，在FrameWork层，状态发生变化后（比如WIFI状态），会遍历全部的register

## 中介者模式
中介者模式包装了一系列对象相互作用的方式，使得这些对象不
必相互明显调用，从而使他们可以轻松解耦。当某些对象之间的作用发生改变时，不会立即影响其他的一些对象之间的作用，保证这些作用可以彼此独立的变化，中介者模式将多对多的相互作用转为一对多的相互作用
在Android中的Binder驱动也是一个中介者，所有的Service在通信之前都会向ServiceManger查询出目标Service，也就是说，进程直接不是直接跨进程，而是由ServiceManager来管理的。所以说Binder启动就是一个中介者模式

## 访问者模式
封装一些作用于某些数据结构中各元素的操作，它可以在不改变这个数据的前提下定义作用于这些元素的新的操作

## 模板方法
定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义该算法的某些特定的步骤
activity 的生命周期
## 备忘录模式
在不破坏封闭的前提下，捕获一个对象的内部状态，并在对象之外保存这个状态，这样，以后就可以将对象恢复到原先保存的状态中
Android下的onSaveInstanceState就在时不时的进行着备忘，在onRestoreInstanceState时，就能取出最后的记录。
## 迭代器模式
提供一种方法顺序访问一个容器对象中的各个元素，而不需要暴露该对象的内部表示。
在Android中SQLiteDatabase的query也是迭代器模式

## 代理模式
为其他类提供一种代理以控制这个对象的访问
AIDL文件会生成一个代理类，在跨进程通信传递数据时，Parcelable对象的序列化与transct写入对方进程的内存地址，这一系列的操作都被代理类进行了隐藏。所以代理模式能很好的隐藏一些复杂的操作
## 组合模式
将对象组成树形结构，以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性
Android中的ViewGroup便是树形结构，每个ViewGroup包含一系列View，而ViewGroup本身就是View。这便是组合模式。

## 装饰模式
动态的给一个对象添加额外的职责。就增加功能来说，装饰模式比子类集成的方式更灵活
ContextWrapper(ContextThemeWrapper的父类(Acrtivity的父类))。是一个地地道道的装饰者

## 外观模式
要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行。
外观模式核心在于子系统与外部通信，比如当你sendBroadcast、startActivity、bindService等等，系统内部的实现非常复杂，但是一个统一的对象context把子系统全部隐藏起来。
## 享元模式
使用享元对象有效地支持大量的细粒度对象
Java的常量池，线程池等。主要是为了重用对象。
在Android中，Handler机制中有个postMessage方法，可以通过Message.obtain()来从消息池中取出可复用Message，避免产生大量Message对象。

## 桥接模式
将抽象部分与实现部分分离，使他们独立地进行变化
一个类在多个维度上要进行变化，比如列表View在列表如何展示与数据来源上的两个维度的变化。
具体来说就是AbsListView的两个维度的变化，AbsListView的子类有ListView、GridView、CustomListView等等，而ListAdapter也是一个变化的维度
## 适配器模式
把一个类的接口变换成客户端所期待的另一个接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。
适配器使用的频率特别高，每个ListView和RecycleView都需要适配器来给出每个ItemView。至于如何给出ItemView，可能不尽相同，但是Adapter给出了一个统一的接口规范，只需要进行一次转换即可。

## MVC MVP MVVM
Model=View=Controller
View=Presenter=Model
View-ViewModel=Model
