## Java 基础
### 关键字

#### volatile

关键字最全总结：原理剖析与实例讲解  可见性  禁止指令重排

[https://blog.csdn.net/u012723673/article/details/80682208](https://blog.csdn.net/u012723673/article/details/80682208)

#### synocnized

自动升级机制

### 原子性实现

### Atomic

### CountDownLatch

### 数据结构
HashMap HashTable 
#### CurrentHashMap
segment+ volatile ArrayList CopyOnWriteArrayList
使用ReentrantLock 控制只有一个线程可以写入
#### LinkedBlockingQueue
head last
putLock takeLock
notEmpty notFull SynchronousQueue


* CopyOnWriteArrayList
写的时候拷贝一个数组  写完了对外提供这个新数组  写的时候不影响读
适合 数组不长 读比较多 的场景

* ConcurrentHashMap
* ConcurrentLinkedQueue
* LinkedBlockingDeque  
双向并发阻塞队列 该阻塞队列同时支持FIFO和FILO两种操作方式，即可以从队列的头和尾同时操作(插入/删除)；并且，该阻塞队列是支持线程安全
* PriorityBlockingQueue

#### 相关面试问题
列举常见的数据结构  并举例使用场景
* 数组
* 稀疏数组 
* 队列 先进先出 可以用数组 链表实现 数组模拟环形队列
* 单向列表 head
* 双向列表  
* 单向环形列表 约瑟夫问题 一个n人坐成一个原 每m个人出列 直到全部出完


#### 线程&多线程
1. extend Thread
2. new Thread(new Runable)
3. AsyncThread
4. HandlerThread
5. Handler + looper + MessageQueue
6. IntentService 用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于IntentService是服务的原因，这导致他的优先级比单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务，因为它的优先级高不容易被系统杀死
#### 线程池
ThreadPoolExecutor 
* FixThreadPool：这是一种线程数量固定的线程池，当线程处于空闲的时候，并不会被回收，除非线程池被关闭了。 
* CachedThreadPool：这是一种线程数量不定的线程池，它只有非核心线程，并且最大线程数为Integer.MAX_VALUE。 
* ScheduledThreadPool：它的核心线程数量是固定的，而非核心线程数是没有限制的，并且当非核心线程闲置时会被立即回收。 
* SingleThreadExecutor：这类线程池内部只有一个核心线程，它确保所有的任务都在同一个线程中按顺序执行。

corePoolSize 
maximumPoolSize 
keepAliveTime 
单位 
任务队列 
threadFactory 
拒绝策略 默认 AbortPolicy RejectedExecutionException

PriorityThreadPoolExecutor

拒绝策略
CallerRunsPolicy NoOpREHandler




